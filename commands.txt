## Commands
This section lists command(s) run by vardict workflow

* Running vardict

```
        set -euo pipefail
        
        mkdir split_beds
        CHROMS=($(seq 1 22) X Y)
        
        for chr in "${CHROMS[@]}"; do
            grep -E "^(chr)?${chr}[[:space:]]" ~{bed_file} > split_beds/chr${chr}.bed || true
            if [ -s split_beds/chr${chr}.bed ]; then
                echo "split_beds/chr${chr}.bed" >> split_beds.list
                # Calculate range size for this bed
                range_size=$(awk '{sum += ($3 - $2)} END {print sum}' split_beds/chr${chr}.bed)
                echo "${range_size}" >> range_sizes.txt
            fi
        done
        min_coff=0.8
        p=0.8
        max_size=$(sort -n range_sizes.txt | tail -n1)

        awk -v max="$max_size" -v min_coff="$min_coff" -v p="$p" '
        {
            size = $1
            ratio = size / max
            coefficient = min_coff + (1 - min_coff) * (ratio ^ p)
            printf "%.2f\n", coefficient
        }' range_sizes.txt > memory_coefficients.txt
```
```
        set -euo pipefail
        cp ~{refFai} .
        
        export JAVA_OPTS="-Xmx$(echo "scale=0; ~{allocatedMemory} * 0.8 / 1" | bc)G"
        $VARDICT_ROOT/bin/VarDict \
            -th ~{numThreads} \
            -G ~{refFasta} \
            -f ~{AF_THR} \
            -N ~{tumor_sample_name} \
            -b "~{tumor_bam}|~{normal_bam}" \
            -Q ~{MAP_QUAL} \
            -P ~{READ_POSITION_FILTER} \
            -c 1 -S 2 -E 3 -g 4 \
             ~{bed_file} | \
            $RSTATS_ROOT/bin/Rscript $VARDICT_ROOT/bin/testsomatic.R | \
            $PERL_ROOT/bin/perl $VARDICT_ROOT/bin/var2vcf_paired.pl \
            -N "~{tumor_sample_name}|~{normal_sample_name}" \
            -f ~{AF_THR} | bgzip  > vardict.vcf.gz

            # the vardict generated vcf header missing contig name, need extract contig lines from refFai
            bcftools view -h vardict.vcf.gz > header.txt     
            while read -r name length rest; do 
                echo "##contig=<ID=$name,length=$length>" 
            done < ~{refFai} >> header.txt

            bcftools reheader -h header.txt -o ~{tumor_sample_name}_~{normal_sample_name}.vardict.vcf.gz vardict.vcf.gz
            tabix -p vcf ~{tumor_sample_name}_~{normal_sample_name}.vardict.vcf.gz
```
```
    set -euo pipefail
    # normalize vcf file from vardict since vardict may generate vcf with non-standard notation
    fixed_vcfs=""

    echo '~{sep="\n" vcfs}' > vcf_files.txt

    while IFS= read -r VCF_FILE; do
      FIXED_VCF="$(basename ${VCF_FILE%.gz})_fixed.vcf"
      
      if [[ $VCF_FILE == *.gz ]]; then
        INPUT_COMMAND="zcat"
      else
        INPUT_COMMAND="cat"
      fi

      $INPUT_COMMAND "$VCF_FILE" | awk '
        BEGIN { dup_pattern = "<dup-[0-9]+>" }
        # Print all header lines unchanged
        /^#/ { print; next }
        # Process non-header lines
        {
          if ($0 ~ dup_pattern) {
            # Extract dup size
            match($0, /<dup-([0-9]+)>/, dup)
            svlen = dup[1]
            end = $2 + svlen
            
            # Replace dup-XX with DUP
            gsub(/<dup-[0-9]+>/, "<DUP>", $5)
            
            # Update INFO field
            if ($8 ~ /TYPE=Insertion/) {
              sub(/TYPE=Insertion/, "SVTYPE=DUP", $8)
              $8 = $8 ";SVLEN=" svlen ";END=" end
            }
          }
          print
        }' > "$FIXED_VCF"

      fixed_vcfs="${fixed_vcfs} ${FIXED_VCF}"
    done < vcf_files.txt

    input_args=""
    for vcf in $fixed_vcfs; do
      input_args="$input_args I=$vcf"
    done

    java "-Xmx~{memory-3}g" -jar $PICARD_ROOT/picard.jar MergeVcfs \
    $input_args \
    O=~{tumor_sample_name}.vardict.vcf.gz \
    SEQUENCE_DICTIONARY=~{refDict}
```
